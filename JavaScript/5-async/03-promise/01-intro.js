// Эмуляции асинхронности через промисы
// Простой пример:

const { reject, parseInt } = require("lodash");

const myProm3000 = new Promise(function(){
    console.log('[myProm3000] Выполнение асинхронной операции');
    setTimeout(() => console.log('[myProm3000] Завершение асинхронной операции'), 3000);
});

const myProm1000 = new Promise(function(){
    console.log('[myProm1000] Выполнение асинхронной операции');
    setTimeout(() => console.log('[myProm1000] Завершение асинхронной операции'), 1000);
});

const myProm2000 = new Promise(function(){
    console.log('[myProm2000] Выполнение асинхронной операции');
    setTimeout(() => console.log('[myProm2000] Завершение асинхронной операции'), 2000);
});

// Вывод:
// [myProm3000] Выполнение асинхронной операции
// [myProm1000] Выполнение асинхронной операции
// [myProm2000] Выполнение асинхронной операции
// [myProm1000] Завершение асинхронной операции
// [myProm2000] Завершение асинхронной операции
// [myProm3000] Завершение асинхронной операции




//// НО. При использовании Промисов, функция, которая передается в конструктор Promise, принимает два параметра: 
// Функция resolve - вызывается в случае успешного выполнения. 
//             Мы можем в нее передать значение, которое мы можем получить в результате успешного выполнения.
// ПОСЛЕ ВЫПОЛНЕНИЯ ЭТОЙ ФУНКЦИИ ПРОМИС ПЕРЕХОДИТ В СТАТУС - fulfilled
// Функция reject вызывается, если выполнение операции завершилось с ошибкой. 
//             Мы можем в нее передать значение, которое представит некоторую информацию об ошибке.
// ПОСЛЕ ВЫПОЛНЕНИЯ ЭТОЙ ФУНКЦИИ ПРОМИС ПЕРЕХОДИТ В СТАТУС - rejected

const x = 4;
const y = 2;
const myP = new Promise((resolve, reject) => {
    const z = x / y;
    y === 0 ? reject('Переданы некорректные данные!') : resolve(z);
});

console.log(myP);  

// ВЫВОД:
// Если у = 0, то получаем ошибку
// Если у = 2, то получаем Promise { 2 }

