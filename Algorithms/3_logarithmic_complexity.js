//// Логарифмическая сложность O(log n)
// Оценка временной сложности O(log n) означает, что время выполнения алгоритма увеличивается логарифмически с увеличением размера входных данных (n). 
// Другими словами, алгоритм становится медленнее, но не линейно, а медленнее в соответствии с логарифмической функцией.

// Пример:
// Бинарный поиск. В этом алгоритме на каждом шаге половина данных отсекается, и поиск продолжается в оставшейся половине. 
//   Это означает, что при увеличении размера входных данных вдвое, бинарный поиск требует всего одного дополнительного шага.

// Эти  алгоритмы эффективны и быстры при работе с большими объемами данных.

const forLogN = [ 1, 2, 4, 5, 7, 13, 1324, 546, 676, 87989 ];

function binarySearch (arr, target) {
    console.time('binarySearch');

    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            console.log(mid);             // элемент найден
            break;
        } else if (arr[mid] <= target) {
            left = mid + 1;               // искать в правой половине 
        } else {
            right = mid - 1;              // искать в левой половине 
        }
    }

    console.log(-1);                      // элемент не найден
    console.timeEnd('binarySearch');
};

binarySearch(forLogN, 13);    // 5
                              // -1
                              // binarySearch: 9.758ms


// Бинарный поиск ищет значение в отсортированном массиве, разделяя его пополам на каждой итерации. Поиск начинается с середины массива. 
// Если значение, которое мы ищем, больше среднего элемента, поиск продолжается в правой половине массива. Если оно меньше, то в левой. 
// Таким образом, на каждой итерации мы уменьшаем область поиска примерно в два раза, что обеспечивает логарифмическую сложность O(log n).