// SOLID 
// Общая идея: использование сразу нескольких принципов как единого целого,
// намного лучше, чем использование принципов по-отдельности

// - S(Single responsibility): Единой ответсвенности;
// У модуля должна быть только одна причина для изменения. Или класс должен отвечать только за что-то одно
// Основная идея: организовать код таким образом, чтобы в случае возникновения изменения задействовать как можно меньшее кол-во модулей
// КОД => *S exSOLID_TS.ts

// - O(Open-closed): Открытости и закрытости;
// Модуль должен быть открыт для расширения, но закрыт для изменений
// Основная идея: разарботка устойчивого к изменениям приложения, а также закладывание такой архитектуры, чтобы небольшое изменение класса не затрагивало кучу связанных с ним модулей  
// Данный принцип помогает проектировать модули выполняющие только одну задачу, вводит абстракции через которые происходит связь с сущностью,
// позволяет расширять имплементацию и защищает ее от изменений, выносит место взаимодействи разных модулей в отдельную прозрачную сущность 
// КОД => *O exSOLID_TS.ts

// - L(Liskov substitution): Принцип подстановки Барабары Лисков;
// Необходимо, чтобы подклассы могли стать заменой для своих супер-классов
// Основная цель: проектировать логику таким образом, чтобы классы-наледники могли использоваться вместо родителей 
// но в большинстве случаев из-за доп проверок логики, лучше использовать для обоих классов использовать общий интерфейс, 
// а не наследоваться одному классу от другого
// Принцип помогает: выявлять проблемные абстакции и скрытые связи между сущностями 
// что делает поведения модулей предсказуемым, а также вводить ограничения на наследование, чтобы как в примере выше потомки 
// не противоречили базовому поведению  
// КОД => *L exSOLID_TS.ts

// - I(Interface segregation): Разделение интерфесов;
// Сущности не должны зависеть от интерфейсов, которые не используют 
// Одна из проблем ООП в том, что при наследовании класс-потомок може получить кучу ненужной функциональности 
// которая в нем не используется 
// Для решения этой проблемы Интерфейсы принято декомпозировать 
// Плюсы этого принципа: снижение зависимости между модулями, при наследовании нет ненужной функциональности, которую требудется реализовать, 
// при внесении изменений затрагиваются только нужные части, а не все зависимые модули, декомпозиция  
// КОД => *I exSOLID_TS.ts

// - D(Dependency inversion): Инверсия зависимостей;
// Общая мысль такова: Верхнеуровневые сущности не должны зависить от низкоуровненвых реализаций, а любые зависимости лучше всего выносить в абстракции (т.е. инкапсулировать в отдельныз сущностях)
// Основная задача: уменьшение межмодульных зависимостей, а следовательно повышение простоты чтения, понимания и тестирования 
// КОД => *D exSOLID_TS.ts

// Данные принципы - это хорошие рекоммендации по архитектуре кода 