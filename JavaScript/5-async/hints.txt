Асинхронный JS

1. Асинхронные функции не возвращают результат асинхронного вычисления через ключевое слово return, а передают его в качестве параметра функции обратного вызова

2. Изначально для передачи результатов из асинхронной функции использовались callback.
   Однако, стоит учитывать, что при черезмерном использовании этих функций 
   мы добиваемся callback hell, и код становится труден в обслуживании.

3. Решением стала поддержка Промисов (начиная с ES 2015).
   Промис (promise) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.
   Асинхронная операция - некоторое действие, выполняемое независимо от окружающего ее кода, в котором она вызывается, не блокирует выполнение вызываемого кода.

  Три возможных состояния промиса:

  1) pending (ожидание) - его начально есостояние. Промис создан, но выполненеие еще не завершено.

  2) fulfilled (успешное завершение)

  3) rejected (завершение с ошибкой)


- Для получения результата операции промиса применяется функция then() объекта Promise.
   Функция then() возвращает также объект Promise.

- Определение промиса через функцию.
   Нередко промис определяется через функцию, которая возвращет объект Promise.

- Простая обработка ошибок. 
   Для получения и обработки ошибки мы можем использовать функцию catch() объекта Promise, которая в качестве параметра принимает функцию обработчика ошибки
   Помимо catch(), метод then() тоже может ее выполнять. 
   Ее второй параметр представляет обработчик ошибки, который в качестве параметра получает переданное из функции reject значение.

- Цепочка промисов.
    Благодаря этому мы можем обрабатывать подряд несколько асинхронных операций - одна за другой.
    С then() все ясно, но нужно помнить, что catch() тоже возвращает объект Промис, а это значит, что после него цепочку можно продолжить!
    finally() будет выполнен при любом исходе!

- Помни про функции Promise.all(), Promise.allSettled() и Promise.race() позволяющие сгруппировать выполнение нескольких промисов.


4. async и await.
   Внедение стандарта ES2017 в JavaScript привнесло два новых оператора: async и await, который призваны упростить работу с промисами.

   Оператор async определяет асинхронную функцию, в которой, как предполагается, будет выполняться одна или несколько асинхронных задач.
   Внутри асинхронной функции мы можем применить оператор await. 
   Он ставится перед вызовом асинхронной операции, которая представляет объект Promise:
   Оператор await приостанавливает выполнение асинхронной функции, пока асинхронная операция (объект Promise) не возвратит результат.
   Стоит учитывать, что оператор await может использоваться только внутри функции, к которой применяется оператор async.

   ВАЖНО!!! Стоит отметить, что для функции, которая определена со словом async неявно создается объект Promise. 

   Для обработки ошибок, которые могут возникнуть в процессе вызова асинхронной операции применяется конструкция try..catch..finally.

5. Асинхронные итераторы (или for-await-of).
   Асинхронные итераторы прежде всего предназначены для обращения к источникам данных, которые используют асинхронный API. 
   Это могут быть какие-нибудь данные, которые загружаются по части, например, по сети, из файловой системы или из базы данных.

   Асинхронный итератор похож на обычный синхронный за тем исключением, что его метод next() возвращает объект Promise. 
   А из промиса, в свою очередь, возвращается объект { value, done }.

   - Цикл for-await-of. Данная форма цикла может использоваться только в функциях, определенных с оператором async!
   - Стоит отметить, что мы НЕ можем использовать для перебора объекта с асинхронным итератором обычный цикл for-of!


6. Асинхронные генераторы.
   Главным преимуществом асинхронным генераторов является то, что мы можем использовать в них оператор await и 
   соответственно получать данные из источников данных, которые используют асинхронный API.