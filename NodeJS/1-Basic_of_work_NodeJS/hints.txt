Курс: https://metanit.com/web/nodejs/1.2.php

ЗАМЕТКИ:

### ОСНОВЫ РАБОТЫ NODE.JS

1. Нода использует модульную систему, т.е. вся встроенная функциональность разбита на отдельные пакеты или модули. 

2. Подключаемые модули кешируются. Это, с одной стороны, увеличивает производительность, а с другой, может создать некоторые проблемы, если мы не будем учитывать этот аспект. 
   За примером иди в 3_work_with_modules

3. Рекомендуется избегать определения и использования глобальных переменных, и преимущественно ориентироваться на создание переменных, инкапсулированных в рамках отдельных модулей.

4. При запуске приложения из терминала/командной строки мы можем передавать ему параметры. 
   Для получения параметров в коде приложения применяется массив process.argv. Это аналогично тому, как в языках C/C++/C#/Java в функцию main передается набор аргументов в виде строкового массива.

5. Работа с пакетным менеджером npm:
   - создать package.json файл `npm init` или `npm init -y`, чтобы пропустить заполнение полей
   - обновить пакетный менеджер до последней версии `npm install npm@latest -g`;
   - узнать версию npm `npm -v`; 
   - установка пакетов `npm install имя_пакета1 имя_пакета2 имя_пакетаN`;
   - удалить установленный пакет `npm uninstall пакет1 пакет2 пакетN`;
   - получить информацию о пакете `npm info [пакет]`;
   
   В примере кода была подгружена библиотека lodash, для упрощения работы с массивами, объектами и другими структурами данных. 
   Она предлагает множество утилитарных функций, которые помогают разработчикам писать более чистый и поддерживаемый код.
   Для более подробной информации иди на официальный сайт - https://lodash.com/docs/4.17.15

6. При работе с package.json в секцию "devDependencies" помещаются пакеты, которые применяются при построении приложения, в в секцию "dependencies" - пакеты, которые применяются при выполнении приложения.
   Вообще при работе с этим файлом есть целое множество всевозможных включаемых секций. 
   Список всех возможных смотри в официальной документации(https://docs.npmjs.com/cli/v10/configuring-npm/package-json), а вот основные из них:
   - name: имя пакета
   - version: версия пакета.
   - description: описание пакета
   - main: главный файл, с которого начинается выполнение
   - keywords: массив ключевых слов. Эти ключевые слова могут использоваться при поиске по репозиторию npm.
   - homepage: адрес домашней страницы проекта
   - license: лицензия пакета
   - author: автор пакета. Если авторов несколько, то указывается главный. Сведения об авторе включают имя. Также дополнительно можно указать email и адрес домашней страницы в сети.
   - contributors: массив, который содержит дополнительных авторов (если их несколько).
   - repository: репозиторий исходного кода проекта
   - dependencies: список зависимостей - других пакетов, которые используются в приложении
   - devDependencies: список зависимостей - других пакетов, которые используются для построения приложения
   - os: поддерживаемые операционные системы

7. Версионирование пакета выглядит так - major.minor.patch. Например: lodash - "4.17.21".
   Если в приложении пофиксили баг, то меняется patch;
   Если в приложении добавилась новая функциональность, то меняется minor;
   Если в приложении добавились изменения, несовместимые с предидущей версией, то меняется major;

8. Добавляем команды в package.json. Например:
   
   "script": {
      "start" : "node app.js",
      "dev": "node app.js Artem 27",
      "test": "echo\"Hello Artem\" && exit 1"
   }

9. В процессе разработки будут вноситься изменения в приложение. Чтобы в ручную не перезагружать сервер для отображения новых данных,
   нужно пользоваться nodemon

   1) npm install nodemon; (Устанавливается в dependencies)
   2)  "script": { "start" : "nodemon app.js" }

   Теперь при изменении файлов програмного кода они будут отображаться автоматически;

10. Для работы с файловой системой в ноде есть специальная библиотека fs.
   Список функциональности смотри в официальной документации - https://nodejs.org/docs/latest-v20.x/api/fs.html
   
   В Node.js модуль fs предоставляет константы, которые используются для проверки прав доступа к файлам и каталогам с помощью функции fs.access(). Вот основные константы, которые вы можете использовать:

   1. fs.constants.F_OK: 
      - Проверяет, существует ли файл или каталог (независимо от прав доступа).

   2. fs.constants.R_OK: 
      - Проверяет, доступен ли файл или каталог для чтения.

   3. fs.constants.W_OK: 
      - Проверяет, доступен ли файл или каталог для записи.

   4. fs.constants.X_OK: 
      - Проверяет, доступен ли файл для исполнения (это применимо к исполняемым файлами, например, скриптам).

   Эти константы можно комбинировать при вызове fs.access() для проверки нескольких прав одновременно. Например, вы можете использовать битовые операторы для комбинирования:

   `fs.access(filePath, fs.constants.R_OK | fs.constants.W_OK, (err) => {
      // Проверяет, доступен ли файл для чтения и записи
   });`

   Таким образом, вы можете проверить права на файл, используя комбинацию этих констант.

11. Event Emitter. Множество функционала Node.js применяет асинхронную событийную архитектуру, где различные действия выполняются в ответ на возникшие события. 
    В подобной архитектуре сначала специальные объекты, которые называются эмиттерами событий (event emitter), генерируют события. 
    Затем специальные функции - обработчики или слушатели событий обрабатывают возникшее событие.

   - on(eventName, listener): 
     Регистрирует обработчик – функцию, которая будет вызвана всякий раз, когда указанное событие произойдет.

   - addListener(eventName, listener):
     Псевдоним метода on(). 
     Регистрирует новый слушатель listener для события eventName.

   - emit(eventName[, args]):
     запускает событие.
     В качестве обязательного параметра принимает имя события. 
     Также дополнительно можно передать необязательный параметр - аргументы для обработчика события

   - eventNames():
     возвращает массив с именами событий, для которых зарегистрированы слушатели
  
   - getMaxListeners():
     возвращает максимальное количество слушателей для данного эмиттера событий.

   - listenerCount(eventName):
     возвращает количество слушателей события eventName

   - listeners(eventName):
     возвращает массив со слушателями события eventName.

   - once(eventName, listener):
     регистрирует новый слушатель listener для события eventName, но выполняет его не более одного раза.

   - prependListener(eventName, listener):
     регистрирует новый слушатель listener для события eventName и помещает его в начало массива слушателей события eventName.

   - prependOnceListener([eventName]):
     аналогичен prependListener() за тем исключением, что слушатель listener вызывается не более одного раза.

   - removeAllListeners([eventName]):
     удаляет всех слушателей события eventName

   - removeListener(eventName, listener):
     удаляет слушателя listener для события eventName.

   - setMaxListeners(n):
     устанавливает максимальное количество слушателей событий, которые можно зарегистрировать для каждого события в эмиттере событий

12. Потоки данных (Stream). 
Основная их концепция — это обработка данных по частям, что очень удобно и не требует расходов больших ресурсов. 
Они бывают 4-х типов: 
   - Readable - потоки для чтения (например, request);
   - Writable - потоки для записи (например, response);
   - Duplex - чтение и запись;
   - Transform - вид Duplex потока, который может изменять данные;
   
   Только работой с файлами функциональность потоков не ограничивается, 
   также имеются сетевые потоки, потоки шифрования, архивации и т.д., 
   но общие принципы работы с ними будут те же, что и у файловых потоков.

   Вообще многие встроенные модули в Node js реализуют стримы, такие как HTTP requests/responses, fs read/write, zlib, crypto, TCP sockets и другие. 

13. Pipe-канал. Связывает потоки для чтения и поток для записии позволяет сразу считать из потока чтения в поток записи.
    Способствует сокращению и улучшению читабельности кода.
    Полезен для таких распространенных задач по работе с файлами. 