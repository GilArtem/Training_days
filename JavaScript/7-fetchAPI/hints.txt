1. Это упрощенная, гибкая и мощная альтернатива  XMLHttpRequest.

  Синтаксис:
	
  > const fetchPromise = fetch(resource [, init]);
    
    - resource: функция, принимает параметры ресурса, к которому функция будет обращаться
    - init: функция, принимает объект с дополнительными настройками запроса


Функция fetch() возвращает объект Promise, который получает ответ после завершения запроса к сетевому ресурсу.
Раз возвращает объект Promise, то это значит, что вместо нанизывания методов then() мы можем использовать операторы async/await для извлечения ответа.

2. Получение ответа. Объект Response и его свойства.
  Для представления ответа от сервера в Fetch API применяется интерфейс Response. 
  Функция fetch() возвращает объект Promise, функция-коллбек в котором в качестве 
  параметра получает объект Response с полученным от сервера ответом:

  fetch("/hello").then(response => /* действия с response */ );

  // или с помощью async/await

  async function getText() {
    // получаем объект ответа
    const response = await fetch("http://localhost:3000/hello");
    // действия с объектом response .......
  };

  - Объект Response имеет следующие свойства:
 !!ВНИМАНИЕ: все эти свойства доступны только для чтения!!

    § body: содержимое ответа в виде объекта ReadableStream;
    
    § bodyUser: хранит булевое значение, которое указывает, было ли содержимое ответа уже использовано;
    
    § headers:  набор заголовков ответа в виде объекта Headers;
    
    § ok: хранит булевое значение, которое указывает, завершился ли запрос успешно 
          (то есть если статусной код ответа находится в диапазоне 200-299);
    
    § redirected: хранит булевое значение, которое указывает, является ли ответ результатом переадресации;
    
    § status: хранит статусный код ответа;
    
    § statusText: хранит сообщение статуса, которое соответствует статусному коду;
    
    § type: хранит тип ответа;
    
    § url: хранит адрес URL. Если в процессе запроса происходит ряд переадресаций, то хранит конечный адрес URL после всех переадресаций;


3. Получение заголовков.
  
  - Для получения данных из заголовков мы можем воспользоваться один из следующих методов интерфейса Headers:

    § entries(): возвращает итератор, который позволяет пройтись по всем заголовкам;
    
    § forEach(): осуществляет перебор заголовков;
    
    § get(): возвращает значение определенного заголовка;
    
    § has(): возвращает true, если установлен определенный заголовок;
    
    § keys(): получает все названия установленных заголовков;
    
    § values(): получает все значения установленных заголовков; 


4. Получение данных из ответа.

  - Все данные, которые отправил сервер, доступны в объекте Response через свойство body,
    которое представляет объект ReadableStream, но гораздо проще воспользоваться одним из 
    методов объекта Response. 
    Интерфейс Response предоставляет следующие методы:

    § arrayBuffer(): возвращает promise, который получает содержимое ответа в виде объекта ArrayBuffer;
    
    § blob(): возвращает promise, который получает содержимое ответа в виде объекта Blob;

    § clone():  возвращает копию текущего объекта Response;

    § error(): возвращает новый объект Response, который ассоциирован с возникшей ошибкой сети;

    § fromData(): возвращает promise, который получает содержимое ответа в виде объекта FormData;

    § json(): возвращает promise, который получает содержимое ответа в виде объекта JSON;

    § redirect():  возвращает новый объект Response с другим адресом URL;

    § text():  возвращает promise, который получает содержимое ответа в виде строки текста;

5. Настройка параметров запроса. 
  Функция fetch() может дополнительно принимать опции запроса в виде второго необязательного параметра:

  - Параметр init представляет сложный объект, который может имеет большой набор опций:
    
    § method: метод запроса, например, GET, POST, PUT и т.д.;

    § headers: устанавливаемые в запросе заголовки;

    § body: тело запроса - данные, которые добавляются в запрос;

    § mode: режим запроса, например, cors, no-cors и same-origin;

    § credentials: определяет действия с учетными данными (куки, данные HTTP-аутентификации и сертификаты клиента TLS). 
      Принимает одно из следующих значений:
       - omit: учетные данные исключаются из запроса, а любые учетные данные, присланные в ответе от сервера, игнорируются;
       - same-origin: учетные данные включаются только в те запросы и принимаются в ответах только на те запросы, адрес которых 
         принадлежит к тому же домену, что и адрес клиента;
       - include: учетные данные включаются в любые запросы и принимаются в ответах на любые запросы;
    
    § cache: устанавливает принцип взаимодействия с кэшем браузера. 
      Возможные значения: default, no-store, reload, no-cache, force-cache и only-if-cached;
    
    § redirect: устанавливает, как реагировать на редиректы. 
      Может принимать следующие значения:
       - follow: автоматически применять редирект;
       - error: при редиректе генерировать ошибку;
       - manual: обрабатывать ответ в другом контексте;

    § referrer: определяет реферера запроса;

    § referrerPolicy: определяет политику реферера - как информация о реферере будет передаваться в запросе. Может принимать следующие значения: 
     - no-referrer, no-referrer-when-downgrade, same-origin, origin, strict-origin, origin-when-cross-origin, strict-origin-when-cross-origin и unsafe-url

    § integrity: содержит контрольное значение ресурса;

    § keepalive: позволяет запросу существовать дольше, чем время жизни веб-страницы;

    § signal: предоставляет объект AbortSignal и позволяет отменить выполнение запроса.

  - Также можно использовать set() метод для установки заголовка, а если он уже ранее был добавлен, 
    то set() заменяет его значение.

    const myHeaders = new Headers();
    myHeaders.append("Accept", "application/json"); // добавляем заголовок Accept
    myHeaders.set("Accept", "text/xml");        // Изменяем значение заголовка
    myHeaders.delete("Accept");                 // Удаляем заголовок

6. Создание клиента для REST API
  Используя Fetch API в JavaScript, можно реализовать полноценный клиент для Web API в стиле REST для взаимодействия с пользователем. Архитектура REST предполагает применение следующих методов или типов запросов HTTP для взаимодействия с сервером:
  
  GET, POST, PUT, DELETE

  